#!/bin/bash

set -euo pipefail

# Buildkite Vault Secrets Plugin
# Based on setup_rt_vault_credentials.sh from Snowflake
# Handles Vault authentication and secret fetching with retry logic

# Use environment variables directly (no plugin config needed)
vault_addr="${VAULT_ADDR:-https://vault.ci1.private.app.snowflake.com:8200}"
vault_path="${VAULT_PATH:-/opt/sfc/vault/}"
vault_role_id="${VAULT_ROLE_ID:-}"
vault_secret_id="${VAULT_SECRET_ID:-}"
skip_verify="${VAULT_SKIP_VERIFY:-1}"

echo "🔐 Starting Vault secrets setup" >&2

# Set up Vault environment (only for this script, don't export to Buildkite)
PATH="$PATH:$vault_path"
VAULT_SKIP_VERIFY="$skip_verify"
VAULT_ADDR="$vault_addr"
VAULT_ROLE_ID="$vault_role_id"
VAULT_SECRET_ID="$vault_secret_id"

# Check if vault command is available
if ! command -v vault &> /dev/null; then
    echo "❌ vault CLI is not installed or not in PATH"
    echo "💡 Expected vault binary at: $vault_path"
    exit 1
fi

# Retry function with exponential backoff
retry() {
    local retries=$1
    shift

    local count=0
    local wait_seconds=5
    until "$@"; do
        exit=$?
        count=$((count + 1))
        if [ $count -lt "$retries" ]; then
            >&2 echo "Retry $count/$retries \"$*\" exited $exit, retrying in $wait_seconds seconds..."
            sleep $wait_seconds
        else
            >&2 echo "Retry $count/$retries \"$*\" exited $exit, no more retries left."
            return $exit
        fi
    done
    return 0
}

# Vault command wrapper with retry logic
vault_with_retry() {
    # Vault by default would retry HTTP requests whose response has status code
    # 412 (client consistency requirement not satisfied) and all 5xx except for
    # 501 (not implemented). See
    # https://www.vaultproject.io/docs/commands#vault_max_retries
    #
    # Since the goal of this function is to implement retry explicitly and retry
    # all http errors, we need to disable the Vault CLI built-in retry behavior
    # by setting VAULT_MAX_RETRIES to 0.
    VAULT_MAX_RETRIES=0 retry 3 vault "$@"
}

# Function to get credentials from Vault
get_cred() {
    local vault_path="${1}"; shift
    local env_name="${1}"; shift
    if [[ $# -gt 0 ]]; then
        local field="${1}"; shift
    else
        local field=data
    fi

    local value
    if value="$(vault_with_retry kv get -field "$field" "$vault_path" 2>&1)"; then
        output "export ${env_name}='${value}'"
        return 0
    else
        echo "❌ Vault error: $value" >&2
        return 1
    fi
}

# Function to get JSON credentials from Vault
get_json_cred(){
    local vault_path="${1}"; shift
    local env_name="${1}"; shift

    local value
    if value="$(vault_with_retry kv get --format=json "$vault_path" 2>&1)"; then
        output "export ${env_name}='${value}'"
        return 0
    else
        echo "❌ Vault error: $value" >&2
        return 1
    fi
}

# Create a temporary file to store export statements
export_file=$(mktemp)

# Uses flock to synchronize writes to export file (if available)
# Why? 'echo' is not always atomic and can cause the output to be interleaved.
# https://stackoverflow.com/questions/9926616/is-echo-atomic-when-writing-single-lines
output() { 
    # Write export statements to temp file
    if command -v flock &> /dev/null; then
        flock /tmp/vault_lockfile -c "echo \"$1\" >> \"$export_file\""
    else
        echo "$1" >> "$export_file"
    fi
}

# Cleanup function to remove temporary file
cleanup_export_file() {
    if [[ -f "$export_file" ]]; then
        rm -f "$export_file"
    fi
}
trap cleanup_export_file EXIT

# Determine authentication method based on user
if [[ $USER != jenkins ]]; then
    echo "🔍 Non-Jenkins user detected: $USER"
    
    # Check if we already have a valid token
    TOKEN_TTL=0
    if [[ -n "${VAULT_TOKEN:-}" ]]; then
        echo "🔑 Checking existing Vault token validity..."
        TOKEN_STATUS=$(vault token lookup -format json 2>/dev/null || echo '{}')
        SUCCESS=$?
        if [ $SUCCESS -eq 0 ]; then
            TOKEN_TTL=$(jq -r '.data.ttl // 0' <<< "$TOKEN_STATUS")
        fi
    fi
    
    # If token is expired or doesn't exist, fail with error
    if [ "$TOKEN_TTL" -eq 0 ]; then
        echo "❌ Vault token is expired on the machine, please refresh the token"
        exit 1
    else
        echo "✅ Using existing valid Vault token (TTL: $TOKEN_TTL seconds)"
    fi
else
    echo "🔍 Jenkins user detected"
    echo "🔐 Authenticating with AppRole..."
    
    # Validate required AppRole credentials
    if [[ -z "$vault_role_id" ]]; then
        echo "❌ VAULT_ROLE_ID needs to be set in env for Jenkins to authenticate to Vault"
        exit 1
    fi
    
    if [[ -z "$vault_secret_id" ]]; then
        echo "❌ VAULT_SECRET_ID needs to be set in env for Jenkins to authenticate to Vault"
        exit 1
    fi
    
    # Authenticate using AppRole
    VAULT_TOKEN="$(vault_with_retry write auth/approle/login role_id="$vault_role_id" secret_id="$vault_secret_id" | grep 's\.' | awk '{print $2}')"
    
    if [[ -z "$VAULT_TOKEN" ]]; then
        echo "❌ Failed to obtain Vault token using AppRole"
        exit 1
    fi
    
    # VAULT_TOKEN is set for this script only, not exported to Buildkite
    echo "✅ Successfully authenticated with AppRole"
fi

# Note: VAULT_TOKEN is already exported to current shell, no need to export to temp file
# The temp file should only contain the actual secrets fetched from Vault

# Process configured secrets
secret_count=0
success_count=0
failed_count=0

echo "🔍 Processing configured secrets..." >&2

# Get the number of secrets configured
while true; do
    path_var="BUILDKITE_PLUGIN_VAULT_SECRETS_SECRETS_${secret_count}_PATH"
    env_name_var="BUILDKITE_PLUGIN_VAULT_SECRETS_SECRETS_${secret_count}_ENV_NAME"
    field_var="BUILDKITE_PLUGIN_VAULT_SECRETS_SECRETS_${secret_count}_FIELD"
    use_json_var="BUILDKITE_PLUGIN_VAULT_SECRETS_SECRETS_${secret_count}_USE_JSON"
    
    vault_path="${!path_var:-}"
    env_name="${!env_name_var:-}"
    field="${!field_var:-data}"
    use_json="${!use_json_var:-false}"
    
    # Break if no more secrets configured
    if [[ -z "$vault_path" ]]; then
        break
    fi
    
    if [[ -n "$vault_path" && -n "$env_name" ]]; then
        # Redact vault path for security - show only last 5 chars
        redacted_path="[REDACTED_VAULT_SECRET_PATH]_${vault_path: -5}"
        
        if [[ "$use_json" == "true" ]]; then
            echo "📥 Fetching secret from vault: $redacted_path -> $env_name (JSON mode)" >&2
            if get_json_cred "$vault_path" "$env_name"; then
                success_count=$((success_count + 1))
                echo "✅ Successfully fetched JSON secret: $redacted_path"
            else
                failed_count=$((failed_count + 1))
                echo "❌ Failed to fetch JSON secret: $redacted_path"
            fi
        else
            echo "📥 Fetching secret from vault: $redacted_path -> $env_name (field: $field)" >&2
            if get_cred "$vault_path" "$env_name" "$field"; then
                success_count=$((success_count + 1))
                echo "✅ Successfully fetched secret: $redacted_path (field: $field)"
            else
                failed_count=$((failed_count + 1))
                echo "❌ Failed to fetch secret: $redacted_path (field: $field)"
            fi
        fi
    else
        echo "❌ Invalid secret configuration at index $secret_count"
        failed_count=$((failed_count + 1))
    fi
    
    secret_count=$((secret_count + 1))
done

# Summary
echo "📊 Vault secrets summary: $success_count succeeded, $failed_count failed"

if [[ $failed_count -gt 0 ]]; then
    echo "❌ Some secrets failed to fetch"
    exit 1
fi

if [[ $success_count -eq 0 ]]; then
    echo "⚠️  No secrets configured to fetch"
fi

echo "🔐 Vault secrets setup completed successfully" >&2

# Source the export file to set environment variables in current shell
# The environment hook runs in the same shell as the main command
if [[ -f "$export_file" && -s "$export_file" ]]; then
    echo "🔧 Setting environment variables from fetched secrets" >&2
    # Source the file to actually set the environment variables
    source "$export_file"
else
    echo "⚠️  No secrets were exported" >&2
fi
